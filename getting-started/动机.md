现今的网站正在不断演进为 web 应用：

* JavaScript 的使用场景越来越广
* 现代浏览器提供了更广泛的接口
* 全页面加载的应用越来越少，取而代之的是更多的单页应用

这就导致了客户端里有**太多**代码啦！

庞大的代码库需要被优化，模块系统提供了一种将代码分割为模块的方式。

# **模块系统类型**

我们有多种标准来规范如何定义依赖和导出值：

* `<script>` - 标签形式（无模块系统）
* CommonJS
* AMD 和一些方言
* ES6 模块化
* 其他方式……

## `<script>`** - 标签形式**

在不使用模块系统的时候，这就是我们操作模块化代码的方式。

```js
<script src="module1.js"></script>
<script src="module2.js"></script>
<script src="libraryA.js"></script>
<script src="module3.js"></script>
```

模块给全局对象（也就是 `window` 对象）导出接口，其他模块可以通过依赖全局对象来访问对应接口。

#### **常见问题**

* 全局对象冲突
* 加载顺序十分重要
* 开发者需要手动解决模块和库的依赖
* 在大项目中这一坨标签会变得冗长且难以管理

## **CommonJs：同步的 **`require`

这个方式使用同步的 `require` 方法以加载依赖并返回导出的接口。一个模块可以通过给 `exports` 对象添加属性或者设置 `module.exports` 的值的方式指定导出的值。

```
require("module");
require("../file.js");
exports.doStuff = function() {};
module.exports = someValue;
```

It’s used server-side by [node.js](http://nodejs.org/).

#### **Pros**

* Server-side modules can be reused.
* There are already many modules written in this style \(npm\).
* Very simple and easy to use.

#### **Cons**

* Blocking calls do not apply well on networks. Network requests are asynchronous.
* No parallel require of multiple modules

#### **Implementations**

* [node.js](http://nodejs.org/) - server-side
* [browserify](https://github.com/substack/node-browserify)
* [modules-webmake](https://github.com/medikoo/modules-webmake) - compile to one bundle
* [wreq](https://github.com/substack/wreq) - client-side

## **AMD: asynchronous require**

`Asynchronous Module Definition`

Other module systems \(for the browser\) had problems with the synchronous `require` \(CommonJS\) and introduced an asynchronous version \(and a way to define modules and exporting values\):

```
require(["module", "../file"], function(module, file) { /* ... */ });
define("mymodule", ["dep1", "dep2"], function(d1, d2) {
  return someExportedValue;
});
```

#### **Pros**

* Fits the asynchronous request style in networks.
* Parallel loading of multiple modules.

#### **Cons**

* Coding overhead. More difficult to read and write.
* Seems to be some kind of workaround.

#### **Implementations**

* [require.js](http://requirejs.org/) - client-side
* [curl](https://github.com/cujojs/curl) - client-side

Read more about [CommonJS](http://webpack.github.io/docs/commonjs.html) and [AMD](http://webpack.github.io/docs/amd.html).

## **ES6 Modules**

EcmaScript6 adds some language constructs to JavaScript, which form another module system.

```
import "jquery";
export function doStuff() {}
module "localModule" {}
```

#### **Pros**

* Static analysis is easy.
* Future-proof as ES standard.

#### **Cons**

* Native browser support will take time.
* Very few modules in this style.

## **Unbiased solution**

Let the developer choose their module style. Allow existing codebases and packages to work. Make it easy to add custom module styles.

---

# **TRANSFERRING**

Modules should be executed on the client, so they must be transferred from the server to the browser.

There are two extremes when transferring modules:

* 1 request per module
* All modules in one request

Both are used in the wild, but both are suboptimal:

* 1 request per module

  * Pro: only required modules are transferred
  * Con: many requests means much overhead
  * Con: slow application startup, because of request latency

* All modules in one request

  * Pro: less request overhead, less latency
  * Con: not \(yet\) required modules are transferred too


## **Chunked transferring**

A more flexible transferring would be better. A compromise between the extremes is better in most cases.

→ While compiling all modules: Split the set of modules into multiple smaller batches \(chunks\).

This allows for multiple smaller, faster requests. The chunks with modules that are not required initially can be loaded on demand. This speeds up the initial load but still lets you grab more code when it will actually be used.

The “split points” are up to the developer.

→ A big code base is possible!

Note: The [idea is from Google’s GWT](https://developers.google.com/web-toolkit/doc/latest/DevGuideCodeSplitting).

Read more about [Code Splitting](http://webpack.github.io/docs/code-splitting.html).

---

# **WHY ONLY JAVASCRIPT?**

Why should a module system only help the developer with JavaScript? There are many other resources that need to be handled:

* stylesheets
* images
* webfonts
* html for templating
* etc.

Or translated\/processed:

* coffeescript → javascript
* elm → javascript
* less stylesheets → css stylesheets
* jade templates → javascript which generates html
* i18n files → something
* etc.

This should be as easy as:

```
require("./style.css");
```

```
require("./style.less");
require("./template.jade");
require("./image.png");
```

Read more about [Using loaders](http://webpack.github.io/docs/using-loaders.html) and [Loaders](http://webpack.github.io/docs/loaders.html).

---

# **STATIC ANALYSIS**

When compiling all these modules, a static analysis tries to find its dependencies.

Traditionally this could only find simple stuff without expression, but `require("./template/" + templateName + ".jade")` is a common construct.

Many libraries are written in different styles. Some of them are very weird…

## **Strategy**

A clever parser would allow most existing code to run. If the developer does something weird, it would try to find the most compatible solution.

